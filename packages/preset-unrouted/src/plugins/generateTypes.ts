import { join } from 'pathe'
import type { HttpMethodOrWildcard, Route, UnroutedContext } from '@unrouted/core'
import { defineUnroutedPlugin, useUnrouted } from '@unrouted/core'
import fse from 'fs-extra'

const ucFirst = (str: string) => str.charAt(0).toUpperCase() + str.slice(1)

async function exportTypes(ctx: UnroutedContext) {
  const { config, routes } = ctx
  const methodStack: Record<Exclude<HttpMethodOrWildcard, '*'>, Route[]> = {
    GET: [],
    HEAD: [],
    POST: [],
    PUT: [],
    DELETE: [],
    CONNECT: [],
    OPTIONS: [],
    TRACE: [],
  }
  let types = '// Generated by unrouted\n'
    + 'type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T\n\n'
  routes.forEach((r) => {
    if (r.meta.runtimeTypes && r.meta.runtimeTypes.includes('export interface'))
      types += `${r.meta.runtimeTypes}\n\n`
  })
  routes.forEach((route) => {
    let methods = route.method
    if (route.method[0] === '*')
      methods = ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'TRACE']

    methods.forEach((method) => {
      if (method !== '*' && method !== 'HEAD')
        methodStack[method].push(route)
    })
  })
  const methodsUsing: Record<string, string> = {}
  // create types based on each method
  for (const m in methodStack) {
    const method = m as Exclude<HttpMethodOrWildcard, '*'>
    const requests = methodStack[method]
    if (requests.length === 0)
      continue
    const name = ucFirst(method.toLowerCase())
    const typeName = `${name}Routes`
    methodsUsing[method.toLowerCase()] = typeName
    types += `export interface ${typeName} {\n`
    const routeTypes = []
    for (const route of methodStack[method]) {
      let path = route.path
      // match the named parma in the path
      if (path.match(/:(\w+)/) || path.endsWith('**')) {
        path = path
          // eslint-disable-next-line no-template-curly-in-string
          .replace(/:(\w+)/, '${string}')
          // eslint-disable-next-line no-template-curly-in-string
          .replace(/\*\*/, '${string}')
      }
      let imp
      if (route.meta.resolve?.file)
        imp = `Awaited<ReturnType<typeof import("${route.meta.resolve.file}").${route.meta.resolve.fn}>>`
      else if (route.meta.runtimeTypes)
        imp = `Awaited<${route.meta.runtimeTypes.includes('export interface') ? route.id : route.meta.runtimeTypes}>`

      routeTypes.push(`  '${path}': ${imp}`)
    }
    types += `${routeTypes.join('\n')}\n}\n\n`
  }
  types += '\n'
    + 'export interface UnroutedApi {\n'
  for (const m in methodsUsing) {
    const typeName = methodsUsing[m]
    types += `  ${m}: ${typeName}\n`
  }
  types += '}\n'

  fse.outputFile(join(config.root, 'unrouted.d.ts'), types, { encoding: 'utf-8' })
}

export default defineUnroutedPlugin({
  meta: {
    name: 'generateTypes',
  },
  setup({ hooks }) {
    hooks.hook('setup:after', async(ctx) => {
      await exportTypes(ctx)
    })

    hooks.hook('request:payload', async({ route }) => {
      if (route.meta.runtimeTypes) {
        const ctx = useUnrouted()
        await exportTypes(ctx)
      }
    })
  },
})
