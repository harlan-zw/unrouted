import type { HTTPMethodOrWildcard, Route, UnroutedContext } from '@unrouted/core'
import fse from 'fs-extra'
import { defineUnroutedPlugin, useUnrouted } from '@unrouted/core'
import { dirname, relative } from 'pathe'

const ucFirst = (str: string) => str.charAt(0).toUpperCase() + str.slice(1)

async function exportFetchTypes(ctx: UnroutedContext, pluginConfig: PluginConfig) {
  const { routes } = ctx
  const methodStack: Record<Exclude<HTTPMethodOrWildcard, '*'>, Route[]> = {
    GET: [],
    HEAD: [],
    POST: [],
    PUT: [],
    DELETE: [],
    CONNECT: [],
    OPTIONS: [],
    TRACE: [],
  }
  let types = '// Generated by unrouted\n'
  types += 'declare module \'@unrouted/core\' {\n'
  types += '  type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T\n'
  routes.forEach((r) => {
    if (r.meta.runtimeTypes && r.meta.runtimeTypes.includes('interface'))
      types += `${r.meta.runtimeTypes}\n\n`
  })
  routes.forEach((route) => {
    let methods = route.method
    if (route.method[0] === '*')
      methods = ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'TRACE']

    methods.forEach((method) => {
      if (method !== '*' && method !== 'HEAD')
        methodStack[method].push(route)
    })
  })
  const methodsUsing: Record<string, string> = {}
  // create types based on each method
  for (const m in methodStack) {
    const method = m as Exclude<HTTPMethodOrWildcard, '*'>
    const requests = methodStack[method]
    if (requests.length === 0)
      continue
    const name = ucFirst(method.toLowerCase())
    const typeName = `${name}Routes`
    methodsUsing[method.toLowerCase()] = typeName
    types += `  interface ${typeName} {\n`
    const routeTypes = []
    for (const route of methodStack[method]) {
      let path = route.path
      // match the named parma in the path
      if (path.match(/:(\w+)/) || path.endsWith('**')) {
        path = path
          // eslint-disable-next-line no-template-curly-in-string
          .replace(/:(\w+)/, '${string}')
          // eslint-disable-next-line no-template-curly-in-string
          .replace(/\*\*/, '${string}')
        path = `[key: \`${path}\`]`
      }
      else {
        path = `'${path}'`
      }
      let imp = 'Awaited<ReturnType<unknown>>'
      if (route.meta.resolve?.file) {
        const relativePath = relative(dirname(pluginConfig.outputPath), route.meta.resolve?.file)
          // stripe extension
          .replace(/\.[^/.]+$/, '')
        imp = `Awaited<ReturnType<typeof import('${relativePath}').${route.meta.resolve?.fn}>>`
      }
      else if (route.meta.resolve?.import) {
        const relativePath = relative(dirname(pluginConfig.outputPath), route.meta.resolve?.import.from)
          // stripe extension
          .replace(/\.[^/.]+$/, '')
        imp = `Awaited<ReturnType<typeof import('${relativePath}').${route.meta.resolve.import.as}>>`
      }
      else if (route.meta.runtimeTypes) {
        imp = `Awaited<${route.meta.runtimeTypes.includes('interface') ? route.id : route.meta.runtimeTypes}>`
      }

      routeTypes.push(`    ${path}: ${imp}`)
    }
    types += `${routeTypes.join('\n')}
  }\n`
  }
  types += '}\n\n'
  types += 'export {}\n'

  await fse.outputFile(pluginConfig.outputPath, types, { encoding: 'utf-8' })
}

async function exportSimpleTypes(ctx: UnroutedContext, pluginConfig: PluginConfig) {
  const { routes } = ctx
  const methodStack: Record<Exclude<HTTPMethodOrWildcard, '*'>, Route[]> = {
    GET: [],
    HEAD: [],
    POST: [],
    PUT: [],
    DELETE: [],
    CONNECT: [],
    OPTIONS: [],
    TRACE: [],
  }
  let types = '// Generated by unrouted\n'
  types += 'export interface RouteSchema {\n'
  routes.forEach((route) => {
    let methods = route.method
    if (route.method[0] === '*')
      methods = ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'TRACE']

    methods.forEach((method) => {
      if (method !== '*' && method !== 'HEAD')
        methodStack[method].push(route)
    })
  })
  // create types based on each method
  for (const m in methodStack) {
    const method = m as Exclude<HTTPMethodOrWildcard, '*'>
    const requests = methodStack[method]
    if (requests.length === 0)
      continue
    types += `  ${method.toLowerCase()}:`
    const routeTypes = []
    for (const route of methodStack[method]) {
      let path = route.path
      // match the named parma in the path
      if (path.match(/:(\w+)/) || path.endsWith('**')) {
        path = path
          // eslint-disable-next-line no-template-curly-in-string
          .replace(/:(\w+)/, '${string}')
          // eslint-disable-next-line no-template-curly-in-string
          .replace(/\*\*/, '${string}')
        routeTypes.push(`  \`${path}\``)
      }
      else {
        routeTypes.push(`  '${path}'`)
      }
    }
    types += `${routeTypes.join('|\n')}\n\n`
  }
  types += '}\n'
  await fse.outputFile(pluginConfig.outputPath, types, { encoding: 'utf-8' })
}

export interface PluginConfig {
  outputPath: string
  declareModule: boolean
}

export default defineUnroutedPlugin<PluginConfig>({
  meta: {
    name: 'generateTypes',
  },
  defaults: {
    declareModule: true,
  },
  setup({ hooks }, config) {
    hooks.hook('setup:after', async(ctx) => {
      if (config.declareModule)
        await exportFetchTypes(ctx, config)
      else
        await exportSimpleTypes(ctx, config)
    })

    hooks.hook('response:before', async({ route }) => {
      if (route.meta.runtimeTypes) {
        const ctx = useUnrouted()
        if (config.declareModule)
          await exportFetchTypes(ctx, config)
        else
          await exportSimpleTypes(ctx, config)
      }
    })
  },
})
